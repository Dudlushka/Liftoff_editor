function exportGameXML()
{
  const name = ui.trackName.value.trim() || "Unnamed";
  const uuid =
    ui.trackUUID.value.trim() || "00000000-0000-0000-0000-000000000000";
  const ver = ui.gameVersion.value.trim() || "1.6.17";

  const env = ui.trackEnvironment.value.trim() || "TheDrawingBoard"

  let xml = `<?xml version=\"1.0\" encoding=\"utf-8\"?>
  <Track xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">`;
  xml += `
  <gameVersion>${ver}</gameVersion>
  <localID>
    <str>${uuid}</str>
    <version>1</version>
    <type>TRACK</type>
  </localID>
  <name>${name}</name>
  <description />
  <dependencies />
  <environment>${env}</environment>
  <blueprints>
`;
  let instanceID = 1;

  const radToDeg = THREE.MathUtils?.radToDeg
    ? THREE.MathUtils.radToDeg
    : (r) => (r * 180) / Math.PI;

  function normalizeDeg(d)
  {
    d = d % 360;
    if (d < 0) d += 360;
    return d;
  }

  function exportNode(node, parentMatrix)
  {
    const M  = new THREE.Matrix4();
    const Rx = new THREE.Matrix4().makeRotationX(deg(node.rotRYP[0]));
    const Ry = new THREE.Matrix4().makeRotationY(deg(node.rotRYP[1]));
    const Rz = new THREE.Matrix4().makeRotationZ(deg(node.rotRYP[2]));
    const S  = new THREE.Matrix4().makeScale(
      node.scale[0],
      node.scale[1],
      node.scale[2],
    );
    const T  = new THREE.Matrix4().makeTranslation(
      node.pos[0],
      node.pos[1],
      node.pos[2],
    );

    M.multiply(parentMatrix)
      .multiply(T)
      .multiply(Rx)
      .multiply(Ry)
      .multiply(Rz)
      .multiply(S);

    if (node.refType === "gp")
    {
      const pos  = new THREE.Vector3();
      const quat = new THREE.Quaternion();
      const scl  = new THREE.Vector3();
      M.decompose(pos, quat, scl);

      // JÁTÉK: YXZ intrinsic sorrend
      const eul = new THREE.Euler().setFromQuaternion(quat, "YXZ");

      let ex = normalizeDeg(radToDeg(eul.x));
      let ey = normalizeDeg(radToDeg(eul.y));
      let ez = normalizeDeg(radToDeg(eul.z));

      xml += `    <TrackBlueprint xsi:type=\"TrackBlueprintFlag\">
`;
      xml += `      <itemID>${node.refName}</itemID>
`;
      xml += `      <instanceID>${instanceID++}</instanceID>
`;
      xml += `      <position>
        <x>${pos.x}</x>
        <y>${pos.y}</y>
        <z>${pos.z}</z>
      </position>
`;
      xml += `      <rotation>
        <x>${ex}</x>
        <y>${ey}</y>
        <z>${ez}</z>
      </rotation>
`;
      xml += `    </TrackBlueprint>
`;
    }
    else
    {
      const grp = store.groups[node.refName];
      if (!grp) return;
      grp.items.forEach((child) => exportNode(child, M));
    }
  }

  const I = new THREE.Matrix4();
  store.scene.forEach((root) => exportNode(root, I));

  xml += `  </blueprints>
  <hideDefaultSpawnpoint>false</hideDefaultSpawnpoint>
</Track>
`;
  
 downloadText("track_export.track", xml);
}






//--------------


//--------------------------------------------------
//YXZ to our XYZ
//--------------------------------------------------
function importGameXML(file)
{
  console.log("import track file:",file);
  const reader = new FileReader();
  reader.onload = () =>
  {
    try
    {
      const text = String(reader.result);
      const dom = new DOMParser().parseFromString(text, "application/xml");

      const name = dom.querySelector("Track > name")?.textContent || "Imported";
      const uuid = dom.querySelector("Track > localID > str")?.textContent || "00000000-0000-0000-0000-000000000000";
      const ver = dom.querySelector("Track > gameVersion")?.textContent || "1.6.17";
      const env = dom.querySelector("Track > environment")?.textContent || "error";

      ui.trackName.value    = name;
      ui.trackUUID.value    = uuid;
      ui.gameVersion.value  = ver;
      ui.trackEnvironment.value = env;

      store.scene.length = 0;

      const degToRad = THREE.MathUtils?.degToRad
        ? THREE.MathUtils.degToRad
        : (d) => d * Math.PI / 180;
      const radToDeg = THREE.MathUtils?.radToDeg
        ? THREE.MathUtils.radToDeg
        : (r) => r * 180 / Math.PI;

      dom.querySelectorAll("blueprints > TrackBlueprint").forEach((bp) =>
      {
        
        
        //const itemID = bp.querySelector("itemID")?.textContent || "UnknownItem";
        //------------------------------
        let rawItemID =
        bp.querySelector("itemID")?.textContent || "UnknownItem";

        let itemID = String(rawItemID);
        const trimmedItemID = itemID.trim();

        if (trimmedItemID !== itemID)
        {
          console.log(
            "[importGameXML] itemID trimmed:",
            JSON.stringify(itemID),
            "->",
            JSON.stringify(trimmedItemID)
          );
        }
        itemID = trimmedItemID;

        //------------------------------


        const px = parseFloat(bp.querySelector("position > x")?.textContent || "0");
        const py = parseFloat(bp.querySelector("position > y")?.textContent || "0");
        const pz = parseFloat(bp.querySelector("position > z")?.textContent || "0");

        const rxGame = parseFloat(bp.querySelector("rotation > x")?.textContent || "0");
        const ryGame = parseFloat(bp.querySelector("rotation > y")?.textContent || "0");
        const rzGame = parseFloat(bp.querySelector("rotation > z")?.textContent || "0");

        // 1) játék Euler (YXZ intrinsic) → quat
        const eGame = new THREE.Euler(
          degToRad(rxGame),
          degToRad(ryGame),
          degToRad(rzGame),
          "YXZ"
        );
        const q = new THREE.Quaternion().setFromEuler(eGame);

        // 2) ugyanaz a quat → a szerkesztő XYZ rendszerébe
        const eLocal = new THREE.Euler().setFromQuaternion(q, "XYZ");

        const rxLocal = radToDeg(eLocal.x);
        const ryLocal = radToDeg(eLocal.y);
        const rzLocal = radToDeg(eLocal.z);

        if (!store.gamePrimitives[itemID])
        {
          store.gamePrimitives[itemID] = {
            name: itemID,
            parts: [
              {
                id: crypto.randomUUID(),
                type: "box",
                color: "#9aa7b1",
                scale: [1, 1, 1],
                pos: [0, 0, 0],
                rotRYP: [0, 0, 0],
              },
            ],
          };
        }

        store.scene.push({
          refType: "gp",
          refName: itemID,
          pos: [px, py, pz],
          // BELSŐ XYZ forgatás fokban
          rotRYP: [rxLocal, ryLocal, rzLocal],
          scale: [1, 1, 1],
        });
      });

      refreshGPList();
      refreshGrpList();
      refreshScnSourceOptions();
      refreshScnList();
      snapshot();
    }
    catch (e)
    {
      console.error(e);
      alert("XML import hiba.");
    }
  };
  reader.readAsText(file);

  console.log("import finished",file);
}






function generateCurrentControlLine()
{
  // --- lokális segédek ---
  const num = (v, def = 0) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : def;
  };
  const modSafe = (a, n) => ((a % n) + n) % n;

  function makeRefFromUI(typeSel, nameSel) {
    const t = typeSel?.value ?? 'null';
    const n = nameSel?.value ?? 'null';
    if (t === 'null' || n === 'null') return null;
    return { refType: t, refName: n };
  }
  function resolveLegacyRef(type, name) {
    if (!name) return null;
    if (type === 'gp')  return { refType:'gp',  refName:name };
    if (type === 'grp') return { refType:'grp', refName:name };
    return null;
  }
  function quatYawFromAuxQuatXYZ(qAux /* THREE.Quaternion */)
  {
    const Zloc = new THREE.Vector3(0,0,1).applyQuaternion(qAux);
    const Zp   = new THREE.Vector3(Zloc.x, 0, Zloc.z);
    if (Zp.lengthSq() <= 1e-8) return new THREE.Quaternion(); // identity
    Zp.normalize();
    const Y = new THREE.Vector3(0,1,0);
    const X = new THREE.Vector3().crossVectors(Y, Zp).normalize();
    const M = new THREE.Matrix4().makeBasis(X, Y, Zp);
    return new THREE.Quaternion().setFromRotationMatrix(M);
  }
  function quatToEulerRYPDeg(q /* THREE.Quaternion */)
  {
    const e = new THREE.Euler().setFromQuaternion(q, 'XYZ');
    return [ e.x*180/Math.PI, e.y*180/Math.PI, e.z*180/Math.PI ];
  }

  // --- guardok ---
  if (ui.mode.value !== "scn") {
    console.warn("[Generate] Scene módban használd.");
    return;
  }
  if (!Array.isArray(store.controlLines) || store.controlLines.length === 0) {
    console.warn("[Generate] Nincs ControlLine.");
    return;
  }
  if (typeof currentCLIndex !== "number" ||
      currentCLIndex < 0 ||
      currentCLIndex >= store.controlLines.length) {
    console.warn("[Generate] Nincs kijelölt ControlLine.");
    return;
  }

  const cl  = store.controlLines[currentCLIndex];
  const pts = Array.isArray(cl.points) ? cl.points : [];

  //------------------------------------------------------------------------------
  // --- aktuális Line/CP referencia UI-ból vagy CL-ből (null támogatás) ---
  const uiLineRef = (ui.clLineRefType && ui.clLineRefName) ? makeRefFromUI(ui.clLineRefType, ui.clLineRefName) : null;
  const uiCPRef = (ui.clCPRefType && ui.clCPRefName) ? makeRefFromUI(ui.clCPRefType, ui.clCPRefName) : null;
  const uiSupportMajorRef = (ui.clSupportMajorRefType && ui.clSupportMajorRefName) ? makeRefFromUI(ui.clSupportMajorRefType, ui.clSupportMajorRefName) : null;
  const uiSupportMinorRef = (ui.clSupportMinorRefType && ui.clSupportMinorRefName) ? makeRefFromUI(ui.clSupportMinorRefType, ui.clSupportMinorRefName) : null;

  // Legacy -> objektumos konverzió (ha régi mezők vannak eltárolva)
  const legacyLineRef  = resolveLegacyRef(cl.lineRefType,  cl.lineRefName);
  const legacyCPRef    = resolveLegacyRef(cl.cpRefType,    cl.cpRefName);
  const legacyMajRef   = resolveLegacyRef(cl.supportMajorRefType, cl.supportMajorRefName);
  const legacyMinRef   = resolveLegacyRef(cl.supportMinorRefType, cl.supportMinorRefName);

  // Végső referenciák prioritással: UI → új objektumos → legacy → null
  let lineRef  = uiLineRef           ?? cl.lineRef           ?? legacyLineRef ?? null;
  let cpRef    = uiCPRef             ?? cl.cpRef             ?? legacyCPRef   ?? null;
  let majRef   = uiSupportMajorRef   ?? cl.supportMajorRef   ?? legacyMajRef  ?? null;
  let minRef   = uiSupportMinorRef   ?? cl.supportMinorRef   ?? legacyMinRef  ?? null;


  console.log("CL line ref: ",lineRef);
  console.log("CP ref: ",cpRef);
  console.log("major ref: ",majRef);
  console.log("minor ref: ",minRef);


  // Visszaírjuk az új (objektumos) formát, hogy mentődjön
  cl.lineRef           = lineRef;
  cl.cpRef             = cpRef;
  cl.supportMajorRef   = majRef;
  cl.supportMinorRef   = minRef;
//------------------------------------------------------------------------------


  // --- Útvonal-elemek lerakása a közös kimenet alapján ---
  if (lineRef && lineRef.refType && lineRef.refName)
  {
    const gen = computeGeneratedPoints(cl);
    for (const g of gen)
    {
      if (!g.active) continue; // lineStyle==0 → kihagyjuk ezt a szakaszt

      const pos = g.pos;  // [x,y,z]
      const q   = new THREE.Quaternion(g.quat[0], g.quat[1], g.quat[2], g.quat[3]);

      // kvaternion → XYZ euler (RYP fokok a te rendszeredhez)
      const rotRYP = quatToEulerRYPDeg(q);

      addSceneItem(
        lineRef.refType,
        lineRef.refName,
        [pos[0], pos[1], pos[2]],
        rotRYP,
        [1, 1, 1]
      );
    }
  } else {
    console.warn("[Generate] hiányzik a Line object (lineRef).");
  }

  // --- SUPPORT generálás (Major/Minor) – a rajzolóval azonos logika ---
  {
    const gen = computeGeneratedPoints(cl); // pos/tan/quat/segIndex/active

    const hasMajor = !!cl.supportMajorRef;
    const hasMinor = !!cl.supportMinorRef;
    const Hmaj     = Math.max(0, num(cl.supportMajorH, 0));
    const Hmin     = Math.max(0, num(cl.supportMinorH, 0));
    const topOff   = num(cl.supportTopOffset, 0);
    const botOff   = num(cl.supportBottomOffset, 0);
    const N        = Math.max(1, num(cl.supportDecimate, 1));
    const off      = num(cl.supportDecimateOffset, 0);
    const doYaw    = !!cl.supportRotate;

    const majorRef = cl.supportMajorRef || null; // {refType,refName} | null
    const minorRef = cl.supportMinorRef || null;

    const canPlace = (ref) => (ref && ref.refType && ref.refName);

    let globalAuxIndex = 0; // TELJES vonal mentén (szakasz-stílustól függetlenül léptetjük)

    for (const g of gen)
    {
      const isActive = g.active === true;
      const segStyle = ((pts[g.segIndex]?.lineStyle)|0) || 0;

      // decimálás globális index alapján
      const take = (modSafe(globalAuxIndex - off, N) === 0);

      if (isActive && take && (segStyle >= 2) && (hasMajor || hasMinor))
      {
        const x = g.pos[0], y = g.pos[1], z = g.pos[2];

        // hasznos függőleges szakasz (offsetekkel)
        const yTop    = y - topOff;
        const yBottom = 0 + botOff;
        const Le      = yTop - yBottom;

        if (Le > 0)
        {
          // yaw (csak Y körül), AUX +Z XZ-vetületével
          let qYaw = new THREE.Quaternion(); // identity
          if (doYaw)
          {
            const qAux = new THREE.Quaternion(g.quat[0], g.quat[1], g.quat[2], g.quat[3]);
            qYaw = quatYawFromAuxQuatXYZ(qAux);
          }
          const rotRYP = quatToEulerRYPDeg(qYaw);

          // Majorok alulról
          let nMaj = 0;
          if (segStyle >= 2 && hasMajor && Hmaj > 0)
          {
            nMaj = Math.floor(Le / Hmaj);
            if (canPlace(majorRef))
            {
              for (let k=0; k<nMaj; k++)
              {
                const yBase = yBottom + k*Hmaj;
                addSceneItem(
                  majorRef.refType, majorRef.refName,
                  [x, yBase, z],
                  rotRYP,
                  [1,1,1]
                );
              }
            }
          }

          // Minorok a majorok tetejétől felfelé
          if (segStyle >= 3 && hasMinor && Hmin > 0)
          {
            const yMajorTop = yBottom + nMaj*Hmaj;
            const R = yTop - yMajorTop;
            if (R > 0 && canPlace(minorRef))
            {
              const nMin = Math.floor(R / Hmin);
              for (let j=0; j<nMin; j++)
              {
                const yBase = yMajorTop + j*Hmin;
                addSceneItem(
                  minorRef.refType, minorRef.refName,
                  [x, yBase, z],
                  rotRYP,
                  [1,1,1]
                );
              }
            }
          }
        }
      }

      globalAuxIndex++; // mindig léptetjük
    }
  }

  // --- Kapuk a CP-kre (csak ahol cp.style != 0) ---
  if (cpRef && cpRef.refType && cpRef.refName)
  {
    for (let i = 0; i < pts.length; i++)
    {
      const cp = pts[i] || { pos: [0, 0, 0], rotRYP: [0, 0, 0], style: 1 };
      if ((cp.style | 0) === 0) continue;
      const p = cp.pos || [0, 0, 0];
      const r = cp.rotRYP || [0, 0, 0];
      addSceneItem(cpRef.refType, cpRef.refName, p, r, [1, 1, 1]);
    }
  }
  else
  {
    // csendben továbblépünk – a kapu opcionális
  }

  refreshScnList?.();
  drawScene?.();
  snapshot?.();
  console.info("[Generate] kész.");
}
